# START HERE: Algorithms Understanding

> Этот файл - короткий теоретический конспект.  
> Полный учебный материал находится в `algorithms/CORE-ALGORITHMS-THEORY.md`.

---

## 1. Что нужно понимать про алгоритмы на интервью

На интервью оценивают не количество задач, а качество мышления:

1. Верно ли решение.
2. Почему оно верно.
3. Какая сложность и почему.
4. Какие есть ограничения и edge cases.

Если ты можешь доказать инвариант и объяснить trade-off, это сильнее любого "заученного шаблона".

---

## 2. Базовая карта алгоритмов

### 2.1 Поиск

- Linear Search: O(n), когда структура не упорядочена.
- Binary Search: O(log n), когда есть монотонность.

Главная идея Binary Search:

- храним диапазон, где ответ точно может быть;
- на каждом шаге безопасно выкидываем половину.

### 2.2 Сортировки

Ключевая троица:

1. Merge Sort: стабильный O(n log n), но O(n) памяти.
2. Quick Sort: обычно очень быстрый, но worst case O(n^2).
3. Heap Sort: гарантированный O(n log n), in-place, но хуже локальность.

### 2.3 Графы

- BFS: слои, кратчайший путь в невзвешенном графе.
- DFS: глубина, циклы, компоненты, топологическая логика.
- Dijkstra: shortest path при неотрицательных весах.
- Topological Sort: порядок зависимостей в DAG.

### 2.4 Деревья

- Traversals: preorder/inorder/postorder/level-order.
- BST: ordered structure (`left < node < right`).
- Типовые темы: depth, LCA, validate BST, path problems.

### 2.5 DP

DP применяем, когда есть:

1. Overlapping subproblems.
2. Optimal substructure.

Критически важно правильно выбрать состояние (state).

### 2.6 Greedy

Greedy работает только когда локальный выбор безопасен глобально.  
Нужен аргумент корректности (exchange/cut property), иначе это гипотеза, а не решение.

### 2.7 Two Pointers / Sliding Window

- Two Pointers убирает лишние вложенные циклы за счёт контролируемого движения границ.
- Sliding Window работает для contiguous подмассивов/подстрок.

### 2.8 Backtracking

Полный перебор с откатом состояния и ранним отсечением (pruning).

### 2.9 Heap / Hash / Union-Find

- Heap: быстрый доступ к экстремуму, top-k, поток.
- HashMap/Set: O(1) average lookup/count/membership.
- Union-Find: динамические компоненты связности.

---

## 3. Инварианты, которые нужно уметь объяснять

1. Binary Search: ответ всегда остаётся внутри текущего диапазона.
2. BFS: первый найденный путь в вершину минимален по числу рёбер.
3. Dijkstra: зафиксированная вершина уже имеет оптимальную дистанцию.
4. Sliding Window: окно поддерживает нужные ограничения счётчиков.
5. DP: `dp[state]` хранит полный ответ для этой подзадачи.

---

## 4. Частые ошибки на интервью

1. Выбор алгоритма до уточнения ограничений (`n`, диапазон значений, online/offline).
2. Путаница "работает на примере" vs "корректно всегда".
3. Нет обоснования сложности.
4. Игнорирование edge cases.
5. Механическое применение DP/Greedy без проверки предпосылок.

---

## 5. Что открыть дальше (материал внутри проекта)

Если хочешь глубоко изучить теорию, открывай:

1. `algorithms/CORE-ALGORITHMS-THEORY.md` - расширенный теоретический материал.
2. `algorithms/COMPLETE-ALGORITHMS-GUIDE.md` - обзор алгоритмов по категориям.
3. `algorithms/by-category/` - детальная проработка категорий.
4. `algorithms/data-structures/` - фундамент структур данных.

Все материалы находятся внутри этого репозитория.

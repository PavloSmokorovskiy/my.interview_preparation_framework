# Greedy Algorithms (Жадные алгоритмы)

## Что такое Greedy? ⭐

**Идея:** На каждом шаге делаем **локально оптимальный выбор**, надеясь получить глобальный оптимум.

### Когда работает

1. **Greedy Choice Property:** Локальный оптимум ведёт к глобальному
2. **Optimal Substructure:** Оптимальное решение содержит оптимальные подрешения

**Опасность:** Не всегда работает! Нужно доказательство или интуиция.

---

## Greedy vs DP

| Greedy | DP |
|--------|-----|
| Один выбор на шаг | Рассматриваем все варианты |
| Не пересматриваем решения | Храним все подрешения |
| Обычно O(n) или O(n log n) | Часто O(n²) или больше |
| Не всегда даёт оптимум | Всегда даёт оптимум (если применим) |

**Совет:** Сначала попробуй greedy. Если есть контрпример → DP.

---

## Классические задачи

### Activity Selection (Interval Scheduling) ⭐

**Задача:** Максимум непересекающихся интервалов.

**Greedy выбор:** Сортируем по **концу**, берём если не пересекается.

```
Интервалы: [(1,3), (2,5), (3,4), (5,7), (6,8)]

Сортируем по концу: [(1,3), (3,4), (2,5), (5,7), (6,8)]

Берём (1,3) ✓
(3,4): 3 >= 3, берём ✓
(2,5): 2 < 4, пропускаем
(5,7): 5 >= 4, берём ✓
(6,8): 6 < 7, пропускаем

Результат: 3 интервала
```

**Почему работает:** Ранний конец оставляет больше места для других.

---

### Fractional Knapsack

**Задача:** Knapsack, но можно брать части items.

**Greedy выбор:** Сортируем по **value/weight**, берём жадно.

```
Items: [(60, 10), (100, 20), (120, 30)]  // (value, weight)
Capacity: 50

value/weight: [6, 5, 4]

Берём item 1 полностью: +60, остаток 40
Берём item 2 полностью: +100, остаток 20
Берём 2/3 item 3: +80

Total: 240
```

**Почему работает:** Максимизируем value на единицу веса.

**Отличие от 0/1 Knapsack:** 0/1 нужен DP, fractional — greedy.

---

### Jump Game

**Задача:** Можно ли добраться до конца массива?

**Greedy:** Отслеживаем максимальную достижимую позицию.

```
nums = [2, 3, 1, 1, 4]

i=0: maxReach = max(0, 0+2) = 2
i=1: maxReach = max(2, 1+3) = 4
i=2: maxReach = max(4, 2+1) = 4
...
maxReach >= last index → True
```

---

### Jump Game II (Minimum Jumps)

**Greedy:** BFS-подобный подход.

```
nums = [2, 3, 1, 1, 4]

Level 0: позиция 0, можем достичь [1, 2]
Level 1: позиции 1,2, можем достичь [2, 3, 4]
Level 2: достигли конец

Jumps = 2
```

---

### Gas Station

**Задача:** Можно ли объехать круг, начав с какой-то станции?

**Greedy наблюдения:**
1. Если total gas >= total cost, решение существует
2. Если из позиции i не достигаем j, то из i+1..j-1 тоже не достигнем
3. Начинаем с первой позиции после "провала"

---

### Task Scheduler

**Задача:** Минимальное время выполнения задач с cooldown.

**Greedy:** Сначала выполняем самые частые задачи.

```
Tasks: [A,A,A,B,B,B], n=2

A _ _ A _ _ A  (idle slots)
A B _ A B _ A B

Время = (maxFreq - 1) * (n + 1) + countMaxFreq
Но не меньше len(tasks)
```

---

### Huffman Coding

**Задача:** Оптимальное prefix-free кодирование.

**Greedy:** Объединяем два минимальных.

```
Frequencies: a:5, b:9, c:12, d:13, e:16, f:45

1. Объединяем a(5) + b(9) = 14
2. Объединяем c(12) + d(13) = 25
3. Объединяем 14 + e(16) = 30
4. Объединяем 25 + 30 = 55
5. Объединяем 45 + 55 = 100

Дерево даёт коды разной длины.
```

---

### Meeting Rooms II (Minimum Rooms)

**Задача:** Минимум переговорок для всех встреч.

**Greedy:** Сортируем по началу, используем min-heap для окончаний.

```
meetings = [(0,30), (5,10), (15,20)]

1. Добавляем (0,30), heap = [30]
2. (5,10): 5 < 30, новая комната, heap = [10, 30]
3. (15,20): 15 >= 10, используем ту же, heap = [20, 30]

Max heap size = 2 комнаты
```

---

### Assign Cookies

**Задача:** Максимум детей с печеньем.

**Greedy:** Сортируем детей и печенье, сопоставляем жадно.

```
Children greed: [1, 2, 3]
Cookies size: [1, 1]

Сортируем оба.
Ребёнок 1 (greed 1) получает печенье 1 ✓
Ребёнок 2 (greed 2) — печенье 1 не подходит, нет больше

Результат: 1
```

---

### Minimum Number of Arrows

**Задача:** Минимум стрел, чтобы лопнуть все шары (интервалы).

**Greedy:** Сортируем по концу, стреляем в конец.

```
Balloons: [(1,6), (2,8), (7,12), (10,16)]

Сортируем по концу: [(1,6), (2,8), (7,12), (10,16)]

Стрела в 6: лопаем (1,6) и (2,8)
Стрела в 12: лопаем (7,12) и (10,16)

Всего: 2 стрелы
```

Похоже на Activity Selection!

---

### Partition Labels

**Задача:** Разбить строку на максимум частей, где каждая буква в одной части.

**Greedy:**
1. Запоминаем последнее вхождение каждой буквы
2. Проходим, расширяя конец текущей части

```
"ababcbacadefegdehijhklij"

Для каждой буквы храним last_index.
Идём слева, расширяем end до last_index текущей буквы.
Когда i == end, это конец части.
```

---

## Паттерны Greedy задач

### 1. Interval Problems
- Сортировка по началу или концу
- Activity Selection, Meeting Rooms, Merge Intervals

### 2. Array Problems
- Один проход, отслеживаем текущий оптимум
- Jump Game, Gas Station

### 3. Two Pointers Greedy
- Сортируем оба массива
- Assign Cookies, Boats to Save People

### 4. Heap Greedy
- Всегда берём min/max
- Meeting Rooms II, Task Scheduler

---

## Как понять, что Greedy сработает

### Признаки
1. Задача про оптимизацию
2. Выбор сейчас не влияет на будущие возможности
3. Локальный оптимум → глобальный

### Проверка
1. Придумай greedy стратегию
2. Попробуй найти контрпример
3. Если нет контрпримера → вероятно работает

### Контрпример для 0/1 Knapsack
```
Items: [(60, 10), (100, 20), (120, 30)]
Capacity: 50

Greedy (by value/weight): берём (60,10), потом (100,20) = 160
Optimal: (100,20) + (120,30) = 220

Greedy НЕ работает для 0/1 Knapsack!
```

---

## Типичные задачи

| Задача | Greedy стратегия |
|--------|-----------------|
| Activity Selection | Сортировка по концу |
| Fractional Knapsack | Сортировка по value/weight |
| Jump Game | Max reachable position |
| Gas Station | Start after "failure" point |
| Task Scheduler | Most frequent first |
| Meeting Rooms II | Min-heap для концов |
| Minimum Arrows | Сортировка по концу |
| Partition Labels | Track last occurrence |
| Assign Cookies | Sort both, match greedily |
| Boats to Save People | Two pointers (heaviest + lightest) |

---

## Запомни

- **Greedy:** Локальный оптимум → глобальный (если работает)
- **Interval задачи:** Сортируй по началу или концу
- **Array задачи:** Один проход, отслеживай max/min
- **Heap:** Когда нужен текущий min/max
- **Проверка:** Ищи контрпример
- **Fallback:** Если greedy не работает → DP

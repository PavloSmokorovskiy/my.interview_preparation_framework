# Сортировки

## Обзор

| Алгоритм | Time (avg) | Time (worst) | Space | Stable | In-place |
|----------|------------|--------------|-------|--------|----------|
| Bubble | O(n²) | O(n²) | O(1) | ✓ | ✓ |
| Selection | O(n²) | O(n²) | O(1) | ✗ | ✓ |
| Insertion | O(n²) | O(n²) | O(1) | ✓ | ✓ |
| **Merge** | O(n log n) | O(n log n) | O(n) | ✓ | ✗ |
| **Quick** | O(n log n) | O(n²) | O(log n) | ✗ | ✓ |
| **Heap** | O(n log n) | O(n log n) | O(1) | ✗ | ✓ |
| Counting | O(n+k) | O(n+k) | O(k) | ✓ | ✗ |
| Radix | O(d·n) | O(d·n) | O(n+k) | ✓ | ✗ |
| Bucket | O(n+k) | O(n²) | O(n) | ✓ | ✗ |

**Важно:** O(n log n) — теоретический минимум для сортировок сравнением.

---

## Простые сортировки O(n²)

### Bubble Sort

**Идея:** Проходим по массиву, меняя соседние элементы если они в неправильном порядке. Повторяем пока массив не отсортирован.

**Визуализация:**
```
[5, 3, 8, 4, 2]
 ↑  ↑
 5 > 3 → swap

[3, 5, 8, 4, 2]
    ↑  ↑
    5 < 8 → ok
...
После прохода 1: [3, 5, 4, 2, 8] (8 "всплыл")
```

**Оптимизация:** Если за проход не было свопов → массив отсортирован.

**Когда использовать:** Никогда в продакшене. Только для обучения.

---

### Selection Sort

**Идея:** Находим минимум в неотсортированной части, меняем с первым элементом неотсортированной части.

**Визуализация:**
```
[5, 3, 8, 4, 2]
         min=2, swap с 5
[2, 3, 8, 4, 5]
    min=3, уже на месте
[2, 3, 8, 4, 5]
       min=4, swap с 8
...
```

**Особенность:** Всегда ровно n(n-1)/2 сравнений, но только n-1 swap.

**Когда использовать:** Когда swaps дорогие (запись на flash память).

---

### Insertion Sort

**Идея:** Берём элемент и вставляем на правильное место в уже отсортированную часть.

**Визуализация:**
```
[5, 3, 8, 4, 2]
    ↑ берём 3
[3, 5, 8, 4, 2]  вставили 3 перед 5
       ↑ берём 8
[3, 5, 8, 4, 2]  8 уже на месте
          ↑ берём 4
[3, 4, 5, 8, 2]  вставили 4
...
```

**Особенность:** O(n) на почти отсортированных данных!

**Когда использовать:**
- Маленькие массивы (< 10-50)
- Почти отсортированные данные
- Онлайн сортировка (данные приходят по одному)
- Как часть гибридных алгоритмов (Timsort, Introsort)

---

## Эффективные сортировки O(n log n)

### Merge Sort ⭐

**Идея:** Divide and Conquer. Разделяем пополам, сортируем каждую часть, сливаем.

**Визуализация:**
```
        [38, 27, 43, 3, 9, 82, 10]
               /           \
    [38, 27, 43, 3]    [9, 82, 10]
       /      \          /     \
  [38, 27]  [43, 3]   [9, 82]  [10]
    / \      / \       / \
 [38][27] [43][3]   [9][82]
    \ /      \ /       \ /
  [27, 38]  [3, 43]  [9, 82]    [10]
       \      /          \       /
    [3, 27, 38, 43]    [9, 10, 82]
              \           /
       [3, 9, 10, 27, 38, 43, 82]
```

**Merge (слияние):**
```
Два отсортированных массива:
[1, 4, 7]  [2, 3, 8]
 ↑          ↑
Сравниваем, берём меньший → [1]
[1, 4, 7]  [2, 3, 8]
    ↑       ↑
→ [1, 2]
...
→ [1, 2, 3, 4, 7, 8]
```

**Характеристики:**
- **Time:** O(n log n) всегда (гарантированно!)
- **Space:** O(n) — нужен вспомогательный массив
- **Stable:** Да

**Когда использовать:**
- Нужна стабильность
- Нужна гарантия O(n log n)
- Сортировка linked lists (слияние O(1) по памяти)
- Внешняя сортировка (данные не влезают в память)

---

### Quick Sort ⭐

**Идея:** Выбираем pivot, разделяем массив на "меньше" и "больше" pivot, рекурсивно сортируем части.

**Partition (разделение):**
```
[3, 7, 8, 5, 2, 1, 9, 4]  pivot=4
          Partition
[3, 2, 1] [4] [7, 8, 5, 9]
 < pivot   =   > pivot
```

**Варианты выбора pivot:**
- Первый/последний элемент (плохо для отсортированных)
- Случайный (random pivot)
- Median-of-three (первый, средний, последний)

**Характеристики:**
- **Time:** O(n log n) avg, O(n²) worst (плохой pivot)
- **Space:** O(log n) — стек рекурсии
- **Stable:** Нет
- **In-place:** Да

**Worst case:** Отсортированный массив + pivot = первый элемент → O(n²)

**Когда использовать:**
- Общий случай — на практике самый быстрый
- Нужна in-place сортировка
- Cache-friendly (хорошая локальность)

---

### Heap Sort

**Идея:** Строим max-heap, извлекаем максимум (ставим в конец), повторяем.

**Шаги:**
1. Build max-heap: O(n)
2. Извлекаем max (swap с последним), heapify корень: O(n log n)

**Характеристики:**
- **Time:** O(n log n) всегда
- **Space:** O(1) — in-place
- **Stable:** Нет

**Когда использовать:**
- Нужна гарантия O(n log n) + in-place
- Как fallback в Introsort

**Почему не всегда:**
- Плохая cache locality (прыжки по массиву)
- На практике медленнее Quick Sort

---

## Линейные сортировки O(n)

### Counting Sort

**Идея:** Считаем количество каждого элемента, затем восстанавливаем массив.

**Шаги:**
1. Создаём count[0..k] = 0
2. Считаем: count[arr[i]]++
3. Prefix sum: count[i] += count[i-1]
4. Строим результат справа налево (для стабильности)

**Пример:**
```
arr = [4, 2, 2, 8, 3, 3, 1]
k = 8

count = [0, 1, 2, 2, 1, 0, 0, 0, 1]
         0  1  2  3  4  5  6  7  8

Результат: [1, 2, 2, 3, 3, 4, 8]
```

**Характеристики:**
- **Time:** O(n + k)
- **Space:** O(k)
- **Stable:** Да

**Ограничения:**
- Только целые числа
- k должно быть разумным (не 10⁹)

**Когда использовать:**
- Целые числа в известном небольшом диапазоне
- Оценки 1-100, ASCII коды и т.д.

---

### Radix Sort

**Идея:** Сортируем по цифрам: сначала по единицам, потом по десяткам, и т.д.

**Пример:**
```
[170, 45, 75, 90, 802, 24, 2, 66]

По единицам (LSD - Least Significant Digit):
[170, 90, 802, 2, 24, 45, 75, 66]

По десяткам:
[802, 2, 24, 45, 66, 170, 75, 90]

По сотням:
[2, 24, 45, 66, 75, 90, 170, 802]
```

**Характеристики:**
- **Time:** O(d · n), где d — количество цифр
- **Space:** O(n + k), где k — основание (обычно 10)
- **Stable:** Да (используем stable sort для каждой цифры)

**Когда использовать:**
- Числа с фиксированным количеством цифр
- Строки фиксированной длины

---

### Bucket Sort

**Идея:** Распределяем элементы по "корзинам" по диапазону, сортируем каждую корзину.

**Шаги:**
1. Создаём n пустых bucket'ов
2. Распределяем элементы по bucket'ам на основе значения
3. Сортируем каждый bucket (обычно insertion sort)
4. Объединяем bucket'ы

**Характеристики:**
- **Time:** O(n) average (при равномерном распределении)
- **Worst:** O(n²) (все в одном bucket)
- **Space:** O(n)

**Когда использовать:**
- Равномерно распределённые данные
- Float числа в [0, 1)

---

## Гибридные алгоритмы

### Timsort (Python, Java)

**Идея:** Merge Sort + Insertion Sort.

- Находит "runs" (уже отсортированные части)
- Маленькие runs сортирует Insertion Sort
- Сливает runs как Merge Sort

**Особенности:**
- O(n) на почти отсортированных данных
- Стабильный
- Используется в Python (sorted, list.sort) и Java (Arrays.sort для objects)

### Introsort (C++ STL)

**Идея:** Quick Sort + Heap Sort + Insertion Sort.

- Начинает как Quick Sort
- При глубокой рекурсии переключается на Heap Sort
- Маленькие подмассивы — Insertion Sort

**Гарантирует:** O(n log n) worst case при скорости Quick Sort.

---

## Какую сортировку выбрать?

| Ситуация | Сортировка |
|----------|------------|
| Общий случай | Quick Sort / Timsort |
| Гарантия O(n log n) | Merge Sort / Heap Sort |
| Стабильность нужна | Merge Sort / Timsort |
| In-place нужен | Quick Sort / Heap Sort |
| Почти отсортирован | Insertion Sort / Timsort |
| Целые числа, малый диапазон | Counting Sort |
| Числа фиксированной длины | Radix Sort |
| Linked list | Merge Sort |

---

## Типичные задачи

| Задача | Подход |
|--------|--------|
| Sort an array | Quick Sort / Merge Sort |
| Sort colors (0,1,2) | Dutch National Flag (3-way partition) |
| K-th largest | Quick Select O(n) |
| Merge sorted arrays | Two pointers |
| Sort linked list | Merge Sort |
| Meeting rooms | Sort by start time |
| Merge intervals | Sort by start, merge |

---

## Запомни

- **O(n²):** Bubble, Selection, Insertion — только для маленьких/особых случаев
- **O(n log n):** Merge, Quick, Heap — основные
- **O(n):** Counting, Radix, Bucket — для специальных данных
- **Merge:** Стабильный, гарантированный, O(n) space
- **Quick:** Быстрый на практике, но O(n²) worst
- **Heap:** Гарантированный O(n log n), in-place, но медленнее
- **Timsort/Introsort:** Гибриды, используются в стандартных библиотеках

# Самопроверка по алгоритмам

**Цель:** 40+/50 для уверенности на интервью.

---

## Инструкция

1. Отвечай вслух или пиши
2. Засекай время: ~30 секунд на вопрос
3. Проверяй по ответам внизу
4. Отмечай слабые места для повторения

---

## Часть 1: Сложности (10 вопросов)

### Вопросы

1. Сложность Binary Search?
2. Сложность Merge Sort (time/space)?
3. Сложность поиска в HashMap (average/worst)?
4. Сложность BFS на графе?
5. Сложность Dijkstra с priority queue?
6. Сложность построения Heap из массива?
7. Сложность добавления в конец Dynamic Array (amortized)?
8. Сложность операций в Union-Find с оптимизациями?
9. Сложность генерации всех permutations?
10. Какая сортировка гарантирует O(n log n) worst case in-place?

<details>
<summary>Ответы</summary>

1. O(log n)
2. Time: O(n log n), Space: O(n)
3. Average: O(1), Worst: O(n)
4. O(V + E)
5. O((V + E) log V)
6. O(n) — не O(n log n)!
7. O(1) amortized
8. O(α(n)) ≈ O(1) amortized
9. O(n!)
10. Heap Sort

</details>

---

## Часть 2: Структуры данных (10 вопросов)

### Вопросы

11. Когда использовать Heap вместо BST?
12. В чём разница между Stack и Queue?
13. Когда использовать Trie?
14. Как найти цикл в Linked List?
15. Разница между HashMap и TreeMap?
16. Что такое Segment Tree и когда использовать?
17. Как реализован Dynamic Array?
18. Что хранит Union-Find?
19. Когда Adjacency Matrix лучше Adjacency List?
20. Что даёт Monotonic Stack?

<details>
<summary>Ответы</summary>

11. Когда нужен только min/max, не поиск произвольного элемента
12. Stack — LIFO (последний первым), Queue — FIFO (первый первым)
13. Для prefix search, autocomplete, spell checker
14. Fast/Slow pointers (Floyd's cycle detection)
15. HashMap O(1) без порядка, TreeMap O(log n) с порядком
16. Дерево для range queries + point updates, O(log n)
17. Массив с resize ×2 при заполнении, amortized O(1) append
18. Parent array для каждого элемента (какому множеству принадлежит)
19. Для плотных графов (E ≈ V²), когда нужна проверка ребра O(1)
20. Решает "next greater/smaller element" за O(n)

</details>

---

## Часть 3: Алгоритмы на графах (10 вопросов)

### Вопросы

21. Когда BFS, а когда DFS?
22. Какой алгоритм для кратчайшего пути с отрицательными весами?
23. Что такое Topological Sort и когда применим?
24. Как детектировать цикл в directed graph?
25. Разница между Kruskal и Prim?
26. Что делает Dijkstra?
27. Когда использовать Floyd-Warshall?
28. Как проверить, что граф bipartite?
29. Что такое DAG?
30. Какую структуру использует BFS?

<details>
<summary>Ответы</summary>

21. BFS — кратчайший путь (невзвешенный), DFS — полный обход, циклы
22. Bellman-Ford
23. Линейный порядок вершин DAG, где u→v значит u перед v. Для зависимостей
24. DFS с тремя цветами: если встретили GRAY → цикл
25. Kruskal — сортировка рёбер + Union-Find, Prim — grow from vertex + heap
26. Кратчайший путь от источника до всех вершин (веса ≥ 0)
27. Когда нужны расстояния между всеми парами, небольшой граф
28. BFS/DFS с чередованием цветов, если конфликт → не bipartite
29. Directed Acyclic Graph — ориентированный граф без циклов
30. Queue

</details>

---

## Часть 4: Паттерны (10 вопросов)

### Вопросы

31. Когда использовать Two Pointers?
32. Что такое Sliding Window и когда применять?
33. Когда Greedy работает?
34. Два ключевых свойства DP?
35. Что такое Backtracking?
36. Когда использовать Binary Search on Answer?
37. Разница между Memoization и Tabulation?
38. Как распознать задачу на DP?
39. Когда использовать Monotonic Deque?
40. Какой паттерн для "все подмножества"?

<details>
<summary>Ответы</summary>

31. Отсортированный массив + поиск пары, in-place модификация
32. Подмассив/подстрока с условием, contiguous
33. Когда локальный оптимум ведёт к глобальному
34. Optimal substructure + Overlapping subproblems
35. Построение решения по частям с откатом при неудаче
36. Когда ответ монотонен и можно проверить "достижимо ли X"
37. Memo — top-down с рекурсией, Tab — bottom-up итеративно
38. "Сколько способов", "min/max", подзадачи
39. Sliding window min/max за O(n)
40. Backtracking O(2ⁿ)

</details>

---

## Часть 5: Конкретные задачи (10 вопросов)

### Вопросы

41. Как найти K-th largest element эффективно?
42. Как проверить, что BST валидный?
43. Алгоритм для Longest Common Subsequence?
44. Как найти LCA в binary tree?
45. Как решить "Two Sum" за O(n)?
46. Алгоритм для "Longest Palindromic Substring"?
47. Как merge K sorted lists?
48. Как найти медиану в потоке чисел?
49. Алгоритм для "Minimum Window Substring"?
50. Как проверить, что строка — перестановка другой?

<details>
<summary>Ответы</summary>

41. Min-heap размера K или Quick Select O(n)
42. DFS с передачей min/max bounds
43. DP 2D: dp[i][j] = dp[i-1][j-1]+1 если совпадают, иначе max(dp[i-1][j], dp[i][j-1])
44. Рекурсия: если нашли p или q в разных поддеревьях → текущий узел LCA
45. HashMap: для каждого x проверяем есть ли (target - x)
46. Expand around center O(n²) или Manacher O(n)
47. Min-heap с K элементами или Divide and Conquer
48. Two heaps: max-heap для меньшей половины, min-heap для большей
49. Sliding Window + Counter/HashMap
50. Sorting O(n log n) или Counter/HashMap O(n)

</details>

---

## Подсчёт результатов

| Баллы | Уровень | Рекомендация |
|-------|---------|--------------|
| 45-50 | Отлично | Готов к интервью |
| 40-44 | Хорошо | Повтори слабые места |
| 30-39 | Средне | Нужно ещё изучение |
| < 30 | Начинающий | Пройди материал заново |

---

## Слабые места для повторения

| Категория | Ссылка на материал |
|-----------|-------------------|
| Сложности | `cheatsheets/big-o-cheatsheet.md` |
| Структуры данных | `data-structures/` |
| Графы | `by-category/03-graphs.md` |
| Паттерны | `cheatsheets/pattern-recognition.md` |
| DP | `by-category/05-dynamic-programming.md` |

---

## Бонус: Быстрый тест (5 вопросов)

Ответь за 2 минуты:

1. Sorted array + find element = ?
2. Shortest path unweighted = ?
3. All permutations complexity = ?
4. Contiguous subarray with condition = ?
5. Min/max in stream = ?

<details>
<summary>Ответы</summary>

1. Binary Search
2. BFS
3. O(n!)
4. Sliding Window
5. Heap

</details>

---

## Часть 6: Глубокое понимание (теория, 30 вопросов)

### Вопросы

51. Почему без монотонности Binary Search некорректен?
52. Какой инвариант у lower_bound?
53. Почему BFS даёт shortest path только в невзвешенном графе?
54. Почему Dijkstra требует неотрицательные веса?
55. Почему Topological Sort невозможен при цикле?
56. Почему local parent-check не валидирует BST полностью?
57. Что такое optimal substructure в DP своими словами?
58. Что такое overlapping subproblems и почему это важно?
59. Почему неправильный порядок обхода в DP ломает ответ?
60. Когда Greedy требует exchange argument?
61. Почему Fractional Knapsack greedy, а 0/1 Knapsack - нет?
62. Почему Sliding Window часто O(n), а не O(n^2)?
63. В чём отличие Two Pointers от Sliding Window концептуально?
64. Почему monotonic deque не теряет максимум окна?
65. Почему Backtracking обычно экспоненциальный?
66. Что делает pruning корректным, а не просто "ускорением"?
67. Почему Merge Sort всегда O(n log n)?
68. Почему Quick Sort может стать O(n^2)?
69. Почему Heap build из массива O(n), а не O(n log n)?
70. Почему HashMap имеет worst-case O(n)?
71. Что такое amortized O(1) append в dynamic array?
72. Почему Union-Find почти O(1), но формально O(alpha(n))?
73. Почему Trie может быть быстрее HashMap для prefix search?
74. Когда TreeMap лучше HashMap в интервью задаче?
75. Почему KMP работает за O(n+m)?
76. Почему hash-collision опасна для Rabin-Karp?
77. Почему `x & (x-1)` убирает младший установленный бит?
78. Почему `n & (n-1) == 0` проверяет степень двойки?
79. Почему Euclid для GCD логарифмический?
80. Почему fast exponentiation работает за O(log n)?

<details>
<summary>Ответы</summary>

51. Нельзя гарантированно отбросить половину пространства без нарушения полноты поиска.
52. Ответ всегда в `[left, right)`, все индексы `< left` точно не подходят.
53. BFS минимизирует число рёбер, что эквивалентно длине пути только при равных весах.
54. Иначе "зафиксированная" вершина может позже улучшиться через отрицательное ребро.
55. Цикл создаёт взаимную зависимость, нарушающую линейный порядок "раньше-позже".
56. Узел может нарушать ограничение предков, даже если корректен относительно parent.
57. Оптимум задачи собирается из оптимумов её подзадач.
58. Одни и те же подзадачи считаются много раз; кэширование даёт ускорение.
59. Текущее состояние использует ещё не посчитанные зависимости.
60. Когда нужно доказать, что greedy-выбор можно встроить в оптимум без потерь.
61. В fractional можно делить предметы; в 0/1 локальный выбор блокирует лучшие комбинации.
62. Каждый указатель (left/right) движется не более n раз.
63. Two pointers чаще про относительное движение двух позиций, window - про поддержание contiguous диапазона и его состояния.
64. Все меньшие элементы сзади доминируются и удаляются; максимум всегда на фронте.
65. Пространство решений растёт как `b^d`.
66. Отсекается только ветка, которая доказуемо не может дать валидный/лучший ответ.
67. Глубина рекурсии `log n`, на каждом уровне merge-работа `O(n)`.
68. При систематически плохом pivot разбиение `n-1` и `0`.
69. Большинство узлов near-leaf и требуют малую высоту sift-down.
70. Из-за коллизий много ключей может попасть в одну корзину.
71. Редкие resize `O(n)` усредняются по множеству дешёвых append.
72. Path compression + union by rank делают деревья почти плоскими.
73. Trie идёт по символам префикса напрямую, без перебора всех ключей.
74. Когда нужны order/range/lower_bound/upper_bound.
75. LPS/префикс-функция не даёт повторно сравнивать уже доказанно совпавшие части.
76. Совпадение hash не гарантирует совпадение строк.
77. Вычитание 1 инвертирует хвост до младшего установленного бита, AND его стирает.
78. У степени двойки ровно один установленный бит.
79. Каждая итерация существенно уменьшает второй аргумент через mod.
80. Степень раскладывается по двоичным битам через repeated squaring.

</details>

---

## Часть 7: Устный экзамен (без формул)

Попроси себя ответить вслух за 60-90 секунд на каждый пункт:

1. "Почему это работает?" для Binary Search.
2. "Почему это работает?" для BFS shortest path.
3. "Почему это работает?" для Dijkstra.
4. "Почему это работает?" для Sliding Window.
5. "Почему это работает?" для одного DP перехода на выбор.

Если ответ расплывчатый или уходит в код, теория ещё не закреплена.
